这份文档详细总结了在 **Source Engine (L4D2 分支)** 中实现基于 **"天然递归 (Natural Recursion)"** 架构的传送门渲染系统的全过程。

该文档基于最终验证通过的代码方案：利用 `DrawModelExecute` 的天然调用栈，配合 `DrawWorldAndEntities` 实现深度优先的递归渲染。

---

# L4D2 传送门渲染系统：天然递归架构技术总结

**版本**：Final Stable
**架构模式**：Depth-First Natural Recursion (DFS)
**核心机制**：利用渲染管线中 `DrawModelExecute` 的回调特性，在绘制传送门模型时“即时”劫持并渲染下一层视图。

---

## 1. 核心架构设计

与预计算队列（BFS）不同，本方案利用引擎自身的递归特性。

### 1.1 渲染流程图

1. **RenderView (Entry)**: 重置递归深度，压入主视角。
2. **Engine Draw Loop**: 引擎开始遍历场景并绘制物体。
3. **DrawModelExecute (Hook)**:
* 检测到正在绘制传送门模型。
* **[关键分岔点]**: 暂停当前模型的绘制。
* 调用 `RenderPortalViewRecursive` 计算并渲染下一层视图到纹理。


4. **RenderPortalViewRecursive**:
* 计算新的摄像机位置（穿越后的视角）。
* 解决可见性剔除（PVS/Frustum）。
* 调用 `DrawWorldAndEntities` (这会再次触发步骤 2，形成递归)。


5. **Recursion Return**:
* 当达到最大深度或遇到阻挡，递归返回。
* `DrawModelExecute` 恢复执行。
* 绑定刚刚渲染好的纹理 (RT)，使用 **Stencil + ScreenSpaceQuad** 将画面“贴”在传送门孔洞上。



---

## 2. 关键技术难点与最终解决方案

在开发过程中，我们攻克了以下核心图形学难题。这也是本系统的技术壁垒。

### 2.1 难题一：卡实体与丢模型 (Visibility Culling)

**现象**：传送门后的场景渲染不全，随着视角转动，部分模型闪烁或消失。
**原因**：

1. **PVS 剔除**：虚拟摄像机位于墙后（虚空），BSP 树认为该区域不可见，不加载 Leaf 数据。
2. **Frustum 剔除**：`Push3DView` 如果没有正确的上下文，引擎会沿用上一层的视锥体进行裁剪。

**最终解决方案 (缺一不可)**：

1. **PVS 欺骗 (`ViewCustomVisibility_t`)**：
* 计算传送门出口前的“安全点” (Safe Origin)。
* 使用 `EngineTrace->GetLeafContainingPoint` 获取该点所在的 Leaf ID。
* 通过 `customVis.ForceViewLeaf` 和 `AddVisOrigin` 强制引擎加载该区域数据。


2. **Frustum 上下文 (`GetFrustum`)**：
* 在 `Push3DView` 时，第四个参数必须传入 `I::CustomView->GetFrustum()`。
* **严禁传入 `nullptr**`。传入 `nullptr` 会导致引擎无法正确更新视锥体裁剪平面，导致固定区域的模型丢失。



### 2.2 难题二：墙壁遮挡 (Clipping)

**现象**：透过传送门看到了出口背后的墙壁内部，或者视野被遮挡。
**解决方案**：

* 使用 **自定义剪裁平面 (Custom Clip Plane)**。
* 公式：`D = Dot(Normal, Origin) + Offset` (根据法线方向调整正负)。
* 将平面略微向门后推移（如 `1.0f`），切除出口处的墙壁几何体。

### 2.3 难题三：透视与画面映射

**现象**：直接将纹理贴在模型上会导致 UV 扭曲，缺乏“窗口”的立体感。
**解决方案**：

* **Stencil Buffer (模板缓冲)**：先绘制传送门模型写入模板（挖洞）。
* **Screen Space Quad**：使用 `DrawScreenSpaceQuad` 绘制全屏纹理。
* **效果**：纹理平铺在屏幕空间，仅通过模板孔洞显示，从而实现完美的透视效果。

---

## 3. 核心代码实现

以下是最终验证通过的关键函数实现。

### 3.1 入口：`RenderView::Detour`

负责初始化状态，依然是整个流程的起点。

```cpp
void __fastcall BaseClient::RenderView::Detour(void* ecx, void* edx, CViewSetup& setup, CViewSetup& hudViewSetup, int nClearFlags, int whatToDraw)
{
    // 1. 重置递归状态
    G::G_L4D2Portal.m_nPortalRenderDepth = 0;
    G::G_L4D2Portal.m_vViewStack.clear();

    // 2. 压入主视角
    G::G_L4D2Portal.m_vViewStack.push_back(setup);
    G::G_L4D2Portal.m_nClearFlags = nClearFlags;

    // 3. 开始引擎绘制循环 -> 这将触发 DrawModelExecute
    Func.Original<FN>()(ecx, edx, setup, hudViewSetup, nClearFlags, whatToDraw);
}

```

### 3.2 递归核心：`RenderPortalViewRecursive`

这是**解决丢模型问题**的核心战场。

```cpp
bool L4D2_Portal::RenderPortalViewRecursive(const CViewSetup& previousView, PortalInfo_t* entryPortal, PortalInfo_t* exitPortal)
{
    // 1. 递归深度限制
    if (m_nPortalRenderDepth >= MAX_PORTAL_RECURSION_DEPTH) return false;

    IMatRenderContext* pRenderContext = G::G_L4D2Portal.m_pMaterialSystem->GetRenderContext();
    if (!pRenderContext) return false;

    // 2. 更新状态与视角栈
    m_nPortalRenderDepth++;
    m_pCurrentExitPortal = exitPortal;
    
    // 计算虚拟摄像机位置 (保持墙后，为了正确的透视)
    CViewSetup newPortalView = CalculatePortalView(previousView, entryPortal, exitPortal);
    m_vViewStack.push_back(newPortalView);

    // 3. 【关键技术点 A】构造 PVS 可见性数据
    // 解决 "摄像机在墙后导致不加载地图数据" 的问题
    ViewCustomVisibility_t customVis;
    Vector exitNormal;
    U::Math.AngleVectors(exitPortal->angles, &exitNormal, nullptr, nullptr);
    
    // 多点采样：寻找出口前方有效的 Leaf
    Vector testPoints[] = {
        exitPortal->origin + (exitNormal * 1.0f), 
        exitPortal->origin + (exitNormal * 25.0f),
        exitPortal->origin + (exitNormal * 50.0f)
    };

    int validLeafIndex = -1;
    for (const auto& pt : testPoints) {
        int leafID = I::EngineTrace->GetLeafContainingPoint(pt);
        if (leafID != -1 && leafID != 0) { 
            customVis.AddVisOrigin(pt);
            if (validLeafIndex == -1) validLeafIndex = leafID;
        }
    }
    // 强制指定 View Leaf，欺骗引擎加载该区域
    if (validLeafIndex != -1) customVis.ForceViewLeaf(validLeafIndex);

    // 4. 准备渲染目标 (Render Target)
    ITexture* pRenderTarget = m_vPortalTextures[m_nPortalRenderDepth - 1];
    pRenderContext->PushRenderTargetAndViewport();
    pRenderContext->SetRenderTarget(pRenderTarget);
    pRenderContext->Viewport(0, 0, pRenderTarget->GetActualWidth(), pRenderTarget->GetActualHeight());
    pRenderContext->ClearColor4ub(0, 0, 0, 255);
    pRenderContext->ClearBuffers(true, true, true);

    // 5. 设置剪裁平面 (Clip Plane) - 切除墙壁
    float clipPlane[4];
    clipPlane[0] = exitNormal.x; clipPlane[1] = exitNormal.y; clipPlane[2] = exitNormal.z;
    // 公式验证：Dot + 1.0f (根据法线方向调整)
    clipPlane[3] = exitNormal.Dot(exitPortal->origin) + 1.0f;
    pRenderContext->PushCustomClipPlane(clipPlane);
    pRenderContext->EnableClipping(true);

    // 6. Push 3D View
    // 【关键技术点 B】Frustum 参数不可为 nullptr！
    // 必须传入 GetFrustum() 以维持正确的视锥体上下文，防止固定丢模型
    I::CustomRender->Push3DView(newPortalView, 0, pRenderTarget, I::CustomView->GetFrustum(), nullptr);
    
    // 7. 渲染场景 (触发递归)
    VisibleFogVolumeInfo_t fog_1; I::CustomRender->GetVisibleFogVolumeInfo(exitPortal->origin, fog_1);
    WaterRenderInfo_t water_1;    I::CustomView->DetermineWaterRenderInfo(&fog_1, &water_1);

    // 调用 DrawWorldAndEntities，这会再次触发 DrawModelExecute
    I::CustomView->DrawWorldAndEntities(true, newPortalView, m_nClearFlags, &fog_1, &water_1, &customVis);
    
    // 8. 恢复环境
    I::CustomRender->PopView(I::CustomView->GetFrustum());
    pRenderContext->EnableClipping(false);
    pRenderContext->PopCustomClipPlane();
    pRenderContext->PopRenderTargetAndViewport();
    
    m_vViewStack.pop_back();
    m_nPortalRenderDepth--;
    return true;
}

```

### 3.3 劫持与贴图：`DrawModelExecute::Detour`

负责拦截绘制，发起递归，并将结果贴回。

```cpp
void __fastcall ModelRender::DrawModelExecute::Detour(...)
{
    // 1. 无限递归保护
    if (G::G_L4D2Portal.m_nPortalRenderDepth > 0) {
        PortalInfo_t* currentExit = G::G_L4D2Portal.m_pCurrentExitPortal;
        // 如果摄像机离出口门太近（正在穿过），跳过绘制，防止遮挡视野
        if (currentExit && pInfo.origin.DistTo(currentExit->origin) < 5.0f) {
            Table.Original<FN>(Index)(ecx, edx, state, pInfo, pCustomBoneToWorld);
            return;
        }
    }

    // ... (模型名称检查 isBluePortal / isOrangePortal) ...

    if (isBluePortal || isOrangePortal) {
        // ... (初始化检查) ...

        // 2. 准备递归参数
        PortalInfo_t* entry = isBluePortal ? &Blue : &Orange;
        PortalInfo_t* exit  = isBluePortal ? &Orange : &Blue;
        const CViewSetup& currentView = G::G_L4D2Portal.m_vViewStack.back();

        // 3. 【发起递归】
        // 这一步会挂起当前绘制，深入下一层去渲染纹理
        bool bRenderSuccess = G::G_L4D2Portal.RenderPortalViewRecursive(currentView, entry, exit);

        if (bRenderSuccess) {
            // 递归返回，纹理已准备好
            ITexture* pTex = G::G_L4D2Portal.m_vPortalTextures[G::G_L4D2Portal.m_nPortalRenderDepth];
            
            // 4. Stencil + Quad 绘制 (核心贴图逻辑)
            IMatRenderContext* pContext = ...;
            
            // A. 写入模板 (Draw Mesh to Stencil)
            pContext->OverrideDepthEnable(false, true);
            I::ModelRender->ForcedMaterialOverride(G::G_L4D2Portal.m_pWriteStencilMaterial);
            // ... SetStencilState(REPLACE, Ref=1/2) ...
            Table.Original<FN>(Index)(...); // 画模型本体
            I::ModelRender->ForcedMaterialOverride(nullptr);

            // B. 绘制纹理 (Draw Quad masked by Stencil)
            // 绑定刚刚递归算出来的纹理
            G::G_L4D2Portal.m_pDynamicPortalMaterial->FindVar("$basetexture")->SetTextureValue(pTex);
            // ... SetStencilState(EQUAL, Ref=1/2) ...
            pContext->DrawScreenSpaceQuad(G::G_L4D2Portal.m_pDynamicPortalMaterial);

            // C. 绘制边框
            // ...
        } else {
            // 递归尽头，绘制纯黑/纯色
            I::ModelRender->ForcedMaterialOverride(G::G_L4D2Portal.m_pBlackoutMaterial);
            Table.Original<FN>(Index)(...);
            I::ModelRender->ForcedMaterialOverride(nullptr);
        }
        return;
    }

    // 普通模型绘制
    Table.Original<FN>(Index)(ecx, edx, state, pInfo, pCustomBoneToWorld);
}

```

---

## 4. 总结

本工程成功证明了在没有源代码的情况下，通过 Hook 方式在 Source 引擎中实现高性能、高质量传送门渲染的可行性。

**核心经验**：

* **尊重引擎机制**：利用 `DrawModelExecute` 的天然递归比手动管理队列更稳定。
* **可见性是关键**：`ViewCustomVisibility_t` 和 `GetFrustum` 是解决“虚空摄像机”导致丢模型问题的两把钥匙。
* **屏幕空间思考**：传送门的本质是 3D 世界中的 2D 窗口，使用 Screen Space Quad 配合 Stencil 是最标准的解法。